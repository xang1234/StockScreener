"""
Universe definition schema — single source of truth for scan universes.

Replaces the loose `universe: str` pattern with a typed, validated model
used across the API, DB persistence, symbol resolution, and retention.
"""
import hashlib
from enum import Enum
from typing import List, Optional

from pydantic import BaseModel, field_validator, model_validator


class UniverseType(str, Enum):
    """Type of stock universe to scan."""
    ALL = "all"
    EXCHANGE = "exchange"
    INDEX = "index"
    CUSTOM = "custom"
    TEST = "test"


class Exchange(str, Enum):
    """Supported stock exchanges."""
    NYSE = "NYSE"
    NASDAQ = "NASDAQ"
    AMEX = "AMEX"


class IndexName(str, Enum):
    """Supported stock market indices."""
    SP500 = "SP500"


class UniverseDefinition(BaseModel):
    """
    Structured definition of a scan universe.

    Validates that the right fields are populated for each universe type:
    - ALL: no extra fields
    - EXCHANGE: exchange required
    - INDEX: index required
    - CUSTOM/TEST: symbols required (non-empty, max 500)
    """
    type: UniverseType
    exchange: Optional[Exchange] = None
    index: Optional[IndexName] = None
    symbols: Optional[List[str]] = None

    @field_validator("symbols", mode="before")
    @classmethod
    def normalize_symbols(cls, v):
        """Trim, uppercase, deduplicate, and remove empty symbols."""
        if v is None:
            return v
        seen = set()
        normalized = []
        for s in v:
            if not isinstance(s, str):
                continue
            s = s.strip().upper()
            if s and s not in seen:
                seen.add(s)
                normalized.append(s)
        return normalized

    @model_validator(mode="after")
    def validate_fields_for_type(self):
        """Ensure correct fields are set for the universe type."""
        t = self.type

        if t == UniverseType.ALL:
            if self.exchange is not None or self.index is not None or self.symbols is not None:
                raise ValueError("ALL universe must not specify exchange, index, or symbols")

        elif t == UniverseType.EXCHANGE:
            if self.exchange is None:
                raise ValueError("EXCHANGE universe requires 'exchange' field")
            if self.index is not None or self.symbols is not None:
                raise ValueError("EXCHANGE universe must not specify index or symbols")

        elif t == UniverseType.INDEX:
            if self.index is None:
                raise ValueError("INDEX universe requires 'index' field")
            if self.exchange is not None or self.symbols is not None:
                raise ValueError("INDEX universe must not specify exchange or symbols")

        elif t in (UniverseType.CUSTOM, UniverseType.TEST):
            if not self.symbols:
                raise ValueError(f"{t.value.upper()} universe requires a non-empty 'symbols' list")
            if len(self.symbols) > 500:
                raise ValueError(f"Symbol list too long ({len(self.symbols)}). Maximum is 500.")

        return self

    def key(self) -> str:
        """
        Canonical key for DB indexing and retention grouping.

        Returns:
            Deterministic string key:
            - "all"
            - "exchange:NYSE"
            - "index:SP500"
            - "custom:<sha256[:12]>"
            - "test:<sha256[:12]>"
        """
        if self.type == UniverseType.ALL:
            return "all"
        elif self.type == UniverseType.EXCHANGE:
            return f"exchange:{self.exchange.value}"
        elif self.type == UniverseType.INDEX:
            return f"index:{self.index.value}"
        else:
            # CUSTOM or TEST — hash the sorted symbol list
            joined = ",".join(sorted(self.symbols))
            digest = hashlib.sha256(joined.encode()).hexdigest()[:12]
            return f"{self.type.value}:{digest}"

    def label(self) -> str:
        """
        Human-readable label for display.

        Returns:
            e.g. "All Stocks", "NYSE", "S&P 500", "Custom (25 symbols)", "Test (5 symbols)"
        """
        if self.type == UniverseType.ALL:
            return "All Stocks"
        elif self.type == UniverseType.EXCHANGE:
            return self.exchange.value
        elif self.type == UniverseType.INDEX:
            if self.index == IndexName.SP500:
                return "S&P 500"
            return self.index.value
        elif self.type == UniverseType.CUSTOM:
            n = len(self.symbols)
            return f"Custom ({n} {'symbol' if n == 1 else 'symbols'})"
        else:  # TEST
            n = len(self.symbols)
            return f"Test ({n} {'symbol' if n == 1 else 'symbols'})"

    @classmethod
    def from_legacy(cls, universe: str, symbols: Optional[List[str]] = None) -> "UniverseDefinition":
        """
        Parse a legacy universe string into a typed UniverseDefinition.

        Supports backward compatibility with existing API calls:
        - "all" -> ALL
        - "nyse" -> EXCHANGE:NYSE
        - "nasdaq" -> EXCHANGE:NASDAQ
        - "amex" -> EXCHANGE:AMEX
        - "sp500" -> INDEX:SP500
        - "custom" -> CUSTOM (requires symbols)
        - "test" -> TEST (requires symbols)

        Args:
            universe: Legacy universe string
            symbols: Optional symbol list for custom/test

        Returns:
            UniverseDefinition instance
        """
        u = universe.strip().lower()

        exchange_map = {
            "nyse": Exchange.NYSE,
            "nasdaq": Exchange.NASDAQ,
            "amex": Exchange.AMEX,
        }

        if u == "all":
            return cls(type=UniverseType.ALL)
        elif u in exchange_map:
            return cls(type=UniverseType.EXCHANGE, exchange=exchange_map[u])
        elif u == "sp500":
            return cls(type=UniverseType.INDEX, index=IndexName.SP500)
        elif u == "custom":
            return cls(type=UniverseType.CUSTOM, symbols=symbols or [])
        elif u == "test":
            return cls(type=UniverseType.TEST, symbols=symbols or [])
        else:
            # Unknown legacy value — treat as custom with the value as context
            # This prevents data loss during migration
            if symbols:
                return cls(type=UniverseType.CUSTOM, symbols=symbols)
            raise ValueError(
                f"Unknown universe '{universe}' and no symbols provided. "
                f"Valid values: all, nyse, nasdaq, amex, sp500, custom, test"
            )
